{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Research Question & Relevance\n",
        "\n",
        "**Research Question:** Can basic heuristic methods effectively identify bot influence on Reddit discussions?\n",
        "\n",
        "**Hypotheses:**\n",
        "\n",
        "-   Account activity heuristics can identify probable bot accounts.\n",
        "-   These accounts may amplify specific narratives or contribute to online polarization.\n",
        "\n",
        "**Relevance:** This study is a preliminary investigation into using simple methods for detecting and analyzing potential bot activity on Reddit. The findings will inform the need for more sophisticated methods to understand bots' broader impact on online discourse.\n",
        "\n",
        "# Data & Measurement {#sec-data}\n",
        "\n",
        "## Data\n",
        "\n",
        "-   **Source:** Reddit API via the Python Reddit API Wrapper (PRAW).\n",
        "-   **Subreddits:** Selected for high subscriber counts and relevance to bot-targeted topics (e.g., politics, news). Keywords for selection will be generated using a reproducible method with Google Gemini (see @sec-keywords for prompt and code). Subreddits will be scored as detailed in @sec-subreddits.\n",
        "-   **Collection:** Posts, comments, timestamps, and available user data like account age and karma.\n",
        "\n",
        "## Measurement\n",
        "\n",
        "-   **Bot Identification (Heuristics):** Accounts flagged as potential bots if they exhibit:\n",
        "    -   Young account age.\n",
        "    -   Unusually low/high karma.\n",
        "    -   High posting frequency.\n",
        "    -   Repetitive content.\n",
        "-   **Analysis:**\n",
        "    -   **Descriptive:** Estimate bot prevalence, compare content from suspected bots versus humans, and analyze bot engagement patterns.\n",
        "    -   **Inferential:** Explore correlations between bot activity and narrative amplification (via keyword analysis) or polarization (via sentiment analysis).\n",
        "    -   **Accuracy Evaluation:** If feasible, build classification models and assess using cross-validation. Test various heuristic combinations, evaluating their performance with standard classification metrics.\n",
        "\n",
        "# Methodology: Challenges, Evaluation, and Scope\n",
        "\n",
        "## Population & Sample\n",
        "\n",
        "-   **Population:** Reddit users, especially in subreddits related to topics often targeted by bots.\n",
        "-   **Sample:** Data from selected subreddits as outlined in @sec-data.\n",
        "\n",
        "## Challenges & Limitations\n",
        "\n",
        "Identifying Reddit bots is difficult because of user anonymity, as well as limited API access for data collection, and the inherent inaccuracy of heuristic detection methods. This study prioritizes a feasible approach, rigorously evaluating the accuracy of heuristics while transparently addressing all limitations. Ethical issues are also considered: only publicly available data will be used, and usernames will be anonymized to protect user privacy. The methodology, including limitations of bot identification, will be documented transparently.\n",
        "\n",
        "## Key Variable Measurement\n",
        "\n",
        "-   **Bot Activity:** Identified using heuristics such as account age, karma, and posting behavior.\n",
        "-   **Narrative Amplification:** Measured by frequency of keywords linked to specific narratives.\n",
        "-   **Polarization:** Assessed using sentiment analysis on discussion content.\n",
        "\n",
        "## Evaluation of Bot Detection\n",
        "\n",
        "The effectiveness of the heuristics will be thoroughly evaluated, including testing different combinations. We will explore leveraging Large Language Models to refine detection. If feasible, simple classification models will be developed and their performance assessed using standard accuracy metrics, offering a quantitative evaluation of the bot detection's effectiveness.\n",
        "\n",
        "## Expected Outcomes\n",
        "\n",
        "This research aims to establish the feasibility of using basic heuristics for bot detection on Reddit and provide preliminary insights into their potential influence on discussions, particularly regarding narrative amplification and polarization. The primary limitations will be the accuracy of the heuristics and the generalizability of the results to all of Reddit.\n",
        "\n",
        "\\newpage\n",
        "\n",
        "# Appendix {.appendix}\n",
        "\n",
        "## Keyword Generation {#sec-keywords}\n",
        "\n",
        "The list of keywords can be generated with the help of a large language model API (e.g. Gemini) tuned for reproducibility (stochastic parameters such as Temperature turned to 0) and includes:\n"
      ],
      "id": "be5b6a29"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import google.generativeai as genai\n",
        "import os\n",
        "\n",
        "genai.configure(api_key=os.environ[\"GEMINI_API_KEY\"])\n",
        "\n",
        "# Create the model\n",
        "generation_config = {\n",
        "  \"temperature\": 0,\n",
        "  # controls randomness.\n",
        "  # 0 = most deterministic\n",
        "  # (always selects highest probability token).\n",
        "  \"top_p\": 0,\n",
        "  # nucleus sampling:\n",
        "  # limits token selection to the most probable.\n",
        "  # 0 = most deterministic (used when temperature > 0).\n",
        "  \"top_k\": 1,\n",
        "  # restricts to top 'k' tokens.\n",
        "  # 1 = most deterministic (used when temperature > 0).\n",
        "  \"max_output_tokens\": 8192,\n",
        "  \"response_mime_type\": \"text/plain\",\n",
        "}\n",
        "\n",
        "model = genai.GenerativeModel(\n",
        "  model_name=\"gemini-exp-1206\",\n",
        "  # best performing gemini model (see: https://livebench.ai)\n",
        "  # api usage is basically unlimited and free of charge\n",
        "  generation_config=generation_config,\n",
        ")\n",
        "\n",
        "import praw\n",
        "import pandas as pd\n",
        "\n",
        "reddit = praw.Reddit(\n",
        "    client_id=os.environ[\"PRAW_CLIENT_ID\"],\n",
        "    client_secret=os.environ[\"PRAW_CLIENT_SECRET\"],\n",
        "    user_agent=os.environ[\"PRAW_USER_AGENT\"],\n",
        "    username=os.environ[\"PRAW_USERNAME\"],\n",
        "    password=os.environ[\"PRAW_PASSWORD\"],\n",
        ")\n",
        "\n",
        "# Fetch a large subset of popular subreddits\n",
        "# (large limit makes this representative of\n",
        "# the largest overall subreddits by subscribers,\n",
        "# check: https://gummysearch.com/tools/top-subreddits/)\n",
        "subreddits = list(reddit.subreddits.popular(limit=1000))\n",
        "\n",
        "# Create a DataFrame containing generated subs list\n",
        "subs_df = pd.DataFrame([{\n",
        "    \"Name\": subreddit.display_name,\n",
        "    \"Subscribers\": subreddit.subscribers,\n",
        "    \"Description\": subreddit.public_description,\n",
        "    \"Over 18\": subreddit.over18,\n",
        "    \"Submission Type\": subreddit.submission_type\n",
        "} for subreddit in subreddits]).sort_values(\n",
        "    by=\"Subscribers\", ascending=False, ignore_index=True)\n",
        "\n",
        "import ast\n",
        "\n",
        "chat_session = model.start_chat()\n",
        "\n",
        "response = chat_session.send_message(\"What are some keywords I can use to create a list of subreddits which are likely to be influenced by bots because of their controversial nature? These are keywords that I would look for within a subreddit's name or description. For example: \\\"news\\\", \\\"politics\\\", \\\"discussion\\\", \\\"war\\\", \\\"vaccines\\\", \\\"controversial\\\", \\\"conflict\\\", etc.\\n\\nKeep the answer short, only including 50 keywords and saving them in a python list as follows [\\\"key1\\\",\\\"key2\\\",...]. Send the output as text not as code.\")\n",
        "\n",
        "bot_influence_keywords = ast.literal_eval(response.candidates[0].content.parts[0].text.replace(\"\\n\", \"\"))\n",
        "\n",
        "for i in range(0, len(bot_influence_keywords), 5):\n",
        "    print(*bot_influence_keywords[i:i+5])"
      ],
      "id": "39113751",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Selected Subreddits {#sec-subreddits}\n",
        "\n",
        "The top 10 subreddits based on this scoring system are:\n"
      ],
      "id": "bba72721"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Score subreddits based on subscribers and keywords in description\n",
        "def calculate_bot_influence_score(row):\n",
        "    score = 0\n",
        "    \n",
        "    # Large subscriber base increases potential for bot activity\n",
        "    if row['Subscribers'] > 10000000:\n",
        "        score += 5\n",
        "    elif row['Subscribers'] > 5000000:\n",
        "        score += 4\n",
        "    elif row['Subscribers'] > 1000000:\n",
        "        score += 3\n",
        "        \n",
        "    # Check for keywords in description and subreddit name\n",
        "    description = row['Description'].lower()\n",
        "    sub_name = row['Name'].lower()\n",
        "    for keyword in bot_influence_keywords:\n",
        "        if keyword in description:\n",
        "            score += 1\n",
        "        if keyword in sub_name:\n",
        "            score += 1\n",
        "            \n",
        "    return score\n",
        "\n",
        "subs_df['Bot Score'] = subs_df.apply(calculate_bot_influence_score, axis=1)\n",
        "\n",
        "# Get top 10 most vulnerable subreddits\n",
        "top_vulnerable = subs_df.nlargest(10, 'Bot Score')[['Name', 'Subscribers', 'Submission Type', 'Bot Score']].reset_index(drop=True)\n",
        "top_vulnerable"
      ],
      "id": "9295412c",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}